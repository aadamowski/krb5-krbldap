K5_AC_INIT([aclocal.m4])
dnl
dnl autoconf 2.49 defaults to a /dev/null cache file, which is what we
dnl do not want for performance reasons. 
if test "x$cache_file" = "x/dev/null"; then
  cache_file=./config.cache
  AC_CACHE_LOAD
fi
dnl
CONFIG_RULES
KRB5_VERSION=K5_VERSION
AC_SUBST(KRB5_VERSION)
dnl
dnl
AC_REQUIRE_CPP
dnl
dnl The following lines are so that configure --help gives some global 
dnl configuration options.
dnl
KRB5_LIB_AUX
AC_KRB5_TCL
AC_ARG_ENABLE([athena],
[  --enable-athena         build with MIT Project Athena configuration],,)
dnl
if test -z "$KRB4_LIB"; then
kadminv4=""
krb524=""
libkrb4=""
KRB4=""
else
kadminv4=kadmin.v4
krb524=krb524
libkrb4=lib/krb4
KRB4=krb4
fi
AC_SUBST(KRB4)
AC_SUBST(krb524)
dnl
dnl Begin autoconf tests for the Makefiles generated out of the top-level
dnl configure.in...
dnl
AC_CHECK_FUNCS(memmove)
KRB5_BUILD_LIBOBJS
KRB5_BUILD_LIBRARY_WITH_DEPS
KRB5_BUILD_PROGRAM
dnl for slave
AC_TYPE_MODE_T
AC_PROG_INSTALL
KRB5_AC_NEED_DAEMON
KRB5_GETSOCKNAME_ARGS
KRB5_GETPEERNAME_ARGS
LIBUTIL=
AC_CHECK_LIB(util,main,[AC_DEFINE(HAVE_LIBUTIL,1,[Define if the util library is available])
LIBUTIL=-lutil
])
AC_SUBST(LIBUTIL)
dnl for kdc
AC_CHECK_HEADERS(syslog.h stdarg.h sys/select.h sys/sockio.h ifaddrs.h unistd.h)
AC_CHECK_FUNCS(openlog syslog closelog strftime vsprintf vasprintf vsnprintf)
KRB5_NEED_PROTO([#include <string.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
/* Solaris 8 declares swab in stdlib.h.  */
#include <stdlib.h>
],swab,1)
dnl
AC_PROG_AWK
KRB5_AC_INET6
KRB5_SOCKADDR_SA_LEN
CHECK_SIGNALS
dnl
dnl --with-vague-errors disables useful error messages.
dnl
AC_ARG_WITH([vague-errors],
AC_HELP_STRING([--with-vague-errors],[Do not @<:@do@:>@ send helpful errors to client]), , withval=no)dnl
if test "$withval" = yes; then
	AC_MSG_RESULT(Supplying vague error messages to KDC clients)
	AC_DEFINE(KRBCONF_VAGUE_ERRORS,1,[Define if the KDC should return only vague error codes to clients])
fi
dnl
dnl --with-kdc-kdb-update makes the KDC update the database with last request
dnl information and failure information.
dnl
AC_ARG_WITH([kdc-kdb-update],
AC_HELP_STRING([--with-kdc-kdb-update],[Update the database @<:@don't update@:>@]), , withval=no)dnl
if test "$withval" = yes; then
	AC_MSG_RESULT(Updating KDC database with each request)
	AC_DEFINE(KRBCONF_KDC_MODIFIES_KDB,1,[Define if KDC should update database with each request])
fi
dnl
dnl Needed for hw-preauth replay detection on KDC.
dnl
dnl USE_RCACHE enables the replay cache
dnl NOCACHE disables the lookaside cache
dnl
dnl The lookaside cache is checked first; if *exactly* the same message
dnl comes in twice, e.g., because the (legitimate) client resent it,
dnl the previous response will be resent.  Otherwise, the replay cache
dnl is used to check for attempts to fake out the KDC.  Some hardware
dnl preauth methods are weak enough that we *really* want to have this
dnl checking turned on.
dnl
AC_ARG_ENABLE([kdc-replay-cache],
AC_HELP_STRING([--enable-kdc-replay-cache],[check for replayed/retransmitted KDC requests (recommended when hardware preauthentication is in use) @<:@disabled@:>@]), , enableval=yes)dnl
if test "$enableval" = yes ; then
	AC_DEFINE(USE_RCACHE,1,[Define if the KDC should use a replay cache])
else
	AC_DEFINE(NOCACHE,1,[Define if the KDC should use no replay cache])
fi
AC_ARG_ENABLE([fakeka],
AC_HELP_STRING([--enable-fakeka],[build the Fake KA server (emulates an AFS kaserver) @<:@default: don't build@:>@]), , enableval=no)dnl
if test "$enableval" = yes; then
	FAKEKA=fakeka
else
	FAKEKA=
fi
AC_SUBST(FAKEKA)
KRB5_RUN_FLAGS
dnl
dnl for krb524
AC_TYPE_SIGNAL
dnl
dnl from old include/configure.in
AH_TEMPLATE([HAVE_STRUCT_SOCKADDR_STORAGE], 
[Define if "struct sockaddr_storage" is available.])
dnl
AC_CONFIG_HEADER(include/autoconf.h)
AC_PROG_INSTALL
AC_PROG_AWK
AC_PROG_LEX
AC_C_CONST
AC_HEADER_DIRENT
AC_CHECK_FUNCS(strdup setvbuf inet_ntoa inet_aton seteuid setresuid setreuid setegid setresgid setregid setsid flock fchmod chmod strftime strptime geteuid setenv unsetenv getenv gethostbyname2 getifaddrs gmtime_r localtime_r pthread_mutex_lock sched_yield bswap16 bswap64 mkstemp getusershell lstat access ftime getcwd srand48 srand srandom stat strchr strerror strerror_r strstr timezone umask waitpid sem_init sem_trywait daemon)
AC_HEADER_STDARG
DECLARE_SYS_ERRLIST
AC_CHECK_HEADERS(unistd.h paths.h regex.h regexpr.h fcntl.h memory.h ifaddrs.h sys/filio.h sched.h byteswap.h machine/endian.h machine/byte_order.h sys/bswap.h endian.h pwd.h arpa/inet.h alloca.h dlfcn.h limits.h pthread.h semaphore.h krb_db.h kdc.h)
AC_CHECK_HEADER(regexp.h, [], [],
[#define INIT char *sp = instring;
#define GETC() (*sp++)
#define PEEKC() (*sp)
#define UNGETC(c) (--sp)
#define RETURN(c) return(c)
#define ERROR(c)
])
AC_CHECK_MEMBERS([struct sockaddr_in.sin_len, struct sockaddr.sa_len], , ,
  [#include <sys/types.h>
#include <netinet/in.h>])
AC_CHECK_MEMBERS([struct stat.st_mtimensec,struct stat.st_mtimespec.tv_nsec,struct stat.st_mtim.tv_nsec],,,[#include <sys/types.h>
#include <sys/stat.h>])
KRB5_AC_REGEX_FUNCS
AC_TYPE_OFF_T
dnl
dnl Fancy caching of perror result...
AC_MSG_CHECKING(for perror declaration)
AC_CACHE_VAL(krb5_cv_decl_perror,
[AC_EGREP_HEADER(perror, errno.h, 
  krb5_cv_decl_perror=yes, krb5_cv_decl_perror=no)])dnl
AC_MSG_RESULT($krb5_cv_decl_perror)
if test $krb5_cv_decl_perror = yes; then
	AC_DEFINE(HDR_HAS_PERROR,1,[Define if errno.h declares perror])
fi
dnl
KRB5_NEED_PROTO([#include <time.h>],strptime)
CHECK_WAIT_TYPE
CHECK_SIGPROCMASK
AC_TYPE_GETGROUPS
CHECK_SETJMP
dnl
dnl *rpcent return types needed for lib/rpc
dnl
AC_MSG_CHECKING([return type of setrpcent])
AC_CACHE_VAL(k5_cv_type_setrpcent,
[AC_TRY_COMPILE([#include <netdb.h>
#ifdef __cplusplus
extern "C"
#endif
extern void setrpcent();],
[int i;], k5_cv_type_setrpcent=void, k5_cv_type_setrpcent=int)])dnl
AC_MSG_RESULT($k5_cv_type_setrpcent)
AC_DEFINE_UNQUOTED(SETRPCENT_TYPE, $k5_cv_type_setrpcent, [Define as return type of setrpcent])
dnl
AC_MSG_CHECKING([return type of endrpcent])
AC_CACHE_VAL(k5_cv_type_endrpcent,
[AC_TRY_COMPILE([#include <netdb.h>
#ifdef __cplusplus
extern "C"
#endif
extern void endrpcent();],
[int i;], k5_cv_type_endrpcent=void, k5_cv_type_endrpcent=int)])dnl
AC_MSG_RESULT($k5_cv_type_endrpcent)
AC_DEFINE_UNQUOTED(ENDRPCENT_TYPE, $k5_cv_type_endrpcent, [Define as return type of endrpcent])
dnl
dnl
dnl bswap_16 is a macro in byteswap.h under GNU libc
AC_MSG_CHECKING(for bswap_16)
AC_CACHE_VAL(krb5_cv_bswap_16,[
AC_TRY_LINK([#if HAVE_BYTESWAP_H
#include <byteswap.h>
#endif],[bswap_16(37);],krb5_cv_bswap_16=yes,krb5_cv_bswap_16=no)])
AC_MSG_RESULT($krb5_cv_bswap_16)
if test "$krb5_cv_bswap_16" = yes; then
  AC_DEFINE(HAVE_BSWAP_16,1,[Define to 1 if bswap_16 is available via byteswap.h])
fi
AC_MSG_CHECKING(for bswap_64)
AC_CACHE_VAL(krb5_cv_bswap_64,[
AC_TRY_LINK([#if HAVE_BYTESWAP_H
#include <byteswap.h>
#endif],[bswap_64(37);],krb5_cv_bswap_64=yes,krb5_cv_bswap_64=no)])
AC_MSG_RESULT($krb5_cv_bswap_64)
if test "$krb5_cv_bswap_64" = yes; then
  AC_DEFINE(HAVE_BSWAP_64,1,[Define to 1 if bswap_64 is available via byteswap.h])
fi
dnl
dnl Needed for ksu and some appl stuff.
dnl
case $krb5_cv_host in
alpha*-dec-osf*)
	AC_CHECK_LIB(security,setluid,
		AC_DEFINE(HAVE_SETLUID,1,[Define if setluid provided in OSF/1 security library])
	)
	;;
esac
dnl
dnl Check what the return types for gethostbyname_r and getservbyname_r are.
dnl
AC_CHECK_FUNC(gethostbyname_r,[
ac_cv_func_gethostbyname_r=yes
if test "$ac_cv_func_gethostbyname_r" = yes; then
  AC_MSG_CHECKING([if gethostbyname_r returns an int])
  AC_CACHE_VAL(krb5_cv_gethostbyname_r_returns_int,
  [AC_TRY_COMPILE([#include <netdb.h>
  extern int gethostbyname_r ();], [1;],
  krb5_cv_gethostbyname_r_returns_int=yes,
  krb5_cv_gethostbyname_r_returns_int=no)])
  AC_MSG_RESULT($krb5_cv_gethostbyname_r_returns_int)

  AC_MSG_CHECKING([if gethostbyname_r returns a pointer])
  AC_CACHE_VAL(krb5_cv_gethostbyname_r_returns_ptr,
  [AC_TRY_COMPILE([#include <netdb.h>
  extern struct hostent *gethostbyname_r ();], [1;],
  krb5_cv_gethostbyname_r_returns_ptr=yes,
  krb5_cv_gethostbyname_r_returns_ptr=no)])
  AC_MSG_RESULT($krb5_cv_gethostbyname_r_returns_ptr)

  if test "$krb5_cv_gethostbyname_r_returns_int" = "$krb5_cv_gethostbyname_r_returns_ptr"; then
    AC_MSG_WARN(cannot determine return type of gethostbyname_r -- disabling)
    ac_cv_func_gethostbyname_r=no
  fi
  if test "$krb5_cv_gethostbyname_r_returns_int" = yes; then
    AC_DEFINE(GETHOSTBYNAME_R_RETURNS_INT, 1, [Define if gethostbyname_r returns int rather than struct hostent * ])
  fi
fi
if test "$ac_cv_func_gethostbyname_r" = yes; then
  AC_DEFINE(HAVE_GETHOSTBYNAME_R, 1, [Define if gethostbyname_r exists and its return type is known])
  AC_CHECK_FUNC(gethostbyaddr_r)
fi
])
dnl

AC_CHECK_FUNC(getpwnam_r,ac_cv_func_getpwnam_r=yes,ac_cv_func_getpwnam_r=no)
AC_CHECK_FUNC(getpwuid_r,ac_cv_func_getpwuid_r=yes,ac_cv_func_getpwuid_r=no)
if test "$ac_cv_func_getpwnam_r" = yes; then
  AC_MSG_CHECKING([return type of getpwnam_r])
  AC_CACHE_VAL(krb5_cv_getpwnam_r_return_type,
  [AC_TRY_COMPILE([#include <pwd.h>
   extern int getpwnam_r();], [1;],
   getpwnam_r_returns_int=yes,getpwnam_r_returns_int=no)
   AC_TRY_COMPILE([#include <pwd.h>
   extern struct passwd *getpwnam_r();], [1;],
   getpwnam_r_returns_ptr=yes,getpwnam_r_returns_ptr=no)
   case "$getpwnam_r_returns_int/$getpwnam_r_returns_ptr" in
     yes/no) krb5_cv_getpwnam_r_return_type=int ;;
     no/yes) krb5_cv_getpwnam_r_return_type=ptr ;;
     *) krb5_cv_getpwnam_r_return_type=unknown ;;
   esac])
  AC_MSG_RESULT($krb5_cv_getpwnam_r_return_type)
  if test $krb5_cv_getpwnam_r_return_type = int; then
    AC_DEFINE(GETPWNAM_R_RETURNS_INT, 1, [Define if getpwnam_r returns an int])
  elif test $krb5_cv_getpwnam_r_return_type = unknown; then
    AC_MSG_WARN([Cannot determine getpwnam_r return type, disabling getpwnam_r])
    ac_cv_func_getpwnam_r=no
  fi
fi
if test "$ac_cv_func_getpwnam_r" = yes; then
  AC_MSG_CHECKING([number of arguments to getpwnam_r])
  AC_CACHE_VAL(krb5_cv_getpwnam_r_args,
  [AC_TRY_COMPILE([#include <pwd.h>
   struct passwd pwx; char buf[1024];],
   [getpwnam_r("", &pwx, buf, sizeof(buf));], args4=yes, args4=no)
   AC_TRY_COMPILE([#include <pwd.h>
   struct passwd pwx, *p; char buf[1024];],
   [getpwnam_r("", &pwx, buf, sizeof(buf), &p);], args5=yes, args5=no)
   case $args4/$args5 in
     yes/no) krb5_cv_getpwnam_r_args=4 ;;
     no/yes) krb5_cv_getpwnam_r_args=5 ;;
     *) krb5_cv_getpwnam_r_args=unknown ;;
   esac])
  AC_MSG_RESULT($krb5_cv_getpwnam_r_args)
  if test "$krb5_cv_getpwnam_r_args" = unknown; then
    AC_MSG_WARN([Cannot determine number of arguments to getpwnam_r, disabling its use.])
    ac_cv_func_getpwnam_r=no
  else
    AC_DEFINE(HAVE_GETPWNAM_R,1,[Define if getpwnam_r is available and useful.])
    if test "$krb5_cv_getpwnam_r_args" = 4; then
      AC_DEFINE(GETPWNAM_R_4_ARGS,1,[Define if getpwnam_r exists but takes only 4 arguments (e.g., POSIX draft 6 implementations like some Solaris releases).])
    fi
  fi
fi

if test "$ac_cv_func_getpwnam_r" = no && test "$ac_cv_func_getpwuid_r" = yes; then
  # Actually, we could do this check, and the corresponding checks
  # for return type and number of arguments, but I doubt we'll run
  # into a system where we'd get to use getpwuid_r but not getpwnam_r.
  AC_MSG_NOTICE([getpwnam_r not useful, so disabling getpwuid_r too])
  ac_cv_func_getpwuid_r=no
fi
if test "$ac_cv_func_getpwuid_r" = yes; then
  AC_DEFINE(HAVE_GETPWUID_R,1,[Define if getpwuid_r is available and useful.])
  # Hack: Assume getpwuid_r is the shorter form if getpwnam_r is.
  if test "$krb5_cv_getpwnam_r_args" = 4; then
    AC_DEFINE(GETPWUID_R_4_ARGS,1,[Define if getpwuid_r exists but takes only 4 arguments (e.g., POSIX draft 6 implementations like some Solaris releases).])
  fi
fi

if test "$ac_cv_func_gmtime_r" = yes; then
  AC_MSG_CHECKING([whether gmtime_r returns int])
  AC_CACHE_VAL(krb5_cv_gmtime_r_returns_int,
  [AC_TRY_COMPILE([#include <time.h>
   extern int gmtime_r ();], [1;], return_int=yes, return_int=no)
   AC_TRY_COMPILE([#include <time.h>
   extern struct tm *gmtime_r ();], [1;], return_ptr=yes, return_ptr=no)
   case $return_int/$return_ptr in
     yes/no) krb5_cv_gmtime_r_returns_int=yes ;;
     no/yes) krb5_cv_gmtime_r_returns_int=no ;;
     *)      # Can't figure it out, punt the function.
             ac_cv_func_gmtime_r=no ;;
   esac])
  if test "$ac_cv_func_gmtime_r" = no; then
    AC_MSG_RESULT(unknown -- ignoring gmtime_r)
  else
    AC_MSG_RESULT($krb5_cv_gmtime_r_returns_int)
    if test "$krb5_cv_gmtime_r_returns_int" = yes; then
      AC_DEFINE(GMTIME_R_RETURNS_INT,1,[Define if gmtime_r returns int instead of struct tm pointer, as on old HP-UX systems.])
    fi
  fi
fi

AC_CHECK_FUNC(getservbyname_r,[
ac_cv_func_getservbyname_r=yes
if test "$ac_cv_func_getservbyname_r" = yes; then
  AC_MSG_CHECKING([if getservbyname_r returns an int])
  AC_CACHE_VAL(krb5_cv_getservbyname_r_returns_int,
  [AC_TRY_COMPILE([#include <netdb.h>
  extern int getservbyname_r ();], [1;],
  krb5_cv_getservbyname_r_returns_int=yes,
  krb5_cv_getservbyname_r_returns_int=no)])
  AC_MSG_RESULT($krb5_cv_getservbyname_r_returns_int)

  AC_MSG_CHECKING([if getservbyname_r returns a pointer])
  AC_CACHE_VAL(krb5_cv_getservbyname_r_returns_ptr,
  [AC_TRY_COMPILE([#include <netdb.h>
  extern struct servent *getservbyname_r ();], [1;],
  krb5_cv_getservbyname_r_returns_ptr=yes,
  krb5_cv_getservbyname_r_returns_ptr=no)])
  AC_MSG_RESULT($krb5_cv_getservbyname_r_returns_ptr)

  if test "$krb5_cv_getservbyname_r_returns_int" = "$krb5_cv_getservbyname_r_returns_ptr"; then
    AC_MSG_WARN(cannot determine return type of getservbyname_r -- disabling)
    ac_cv_func_getservbyname_r=no
  fi
  if test "$krb5_cv_getservbyname_r_returns_int" = yes; then
    AC_DEFINE(GETSERVBYNAME_R_RETURNS_INT, 1, [Define if getservbyname_r returns int rather than struct servent * ])
  fi
fi
if test "$ac_cv_func_getservbyname_r" = yes; then
  AC_DEFINE(HAVE_GETSERVBYNAME_R, 1, [Define if getservbyname_r exists and its return type is known])
  AC_CHECK_FUNC(getservbyport_r)
fi
])
dnl
HAVE_YYLINENO
CHECK_DIRENT
AC_TYPE_UID_T
AC_TYPE_MODE_T
dnl
AC_CHECK_HEADER(termios.h,dnl
[AC_CHECK_FUNC([tcsetattr],dnl
  AC_DEFINE(POSIX_TERMIOS,1,[Define if termios.h exists and tcsetattr exists]))])
dnl
KRB5_SIGTYPE
AC_CHECK_HEADERS(stdlib.h string.h stddef.h sys/types.h sys/file.h sys/param.h sys/stat.h sys/time.h netinet/in.h sys/uio.h sys/filio.h sys/select.h time.h paths.h)
AC_HEADER_STDARG
KRB5_AC_INET6
dnl
dnl If compiling with IPv6 support, test if in6addr_any functions.
dnl Irix 6.5.16 defines it, but lacks support in the C library.
if test $krb5_cv_inet6 = yes || test "$krb5_cv_inet6_with_dinet6" = yes ; then
AC_CACHE_CHECK([for in6addr_any definition in library], 
  krb5_cv_var_in6addr_any,
[AC_TRY_LINK([
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
],[
  struct sockaddr_in6 in;
  in.sin6_addr = in6addr_any;
  printf("%x", &in);
],krb5_cv_var_in6addr_any=yes, krb5_cv_var_in6addr_any=no)])
  if test $krb5_cv_var_in6addr_any = no; then
    AC_DEFINE(NEED_INSIXADDR_ANY,1,[Define if in6addr_any is not defined in libc])
  fi
fi

dnl
dnl
dnl check for ANSI stdio, esp "b" option to fopen().  This (unfortunately)
dnl requires a run check...
dnl
AC_MSG_CHECKING([for ANSI stdio])
AC_CACHE_VAL(krb5_cv_has_ansi_stdio,
[AC_TRY_RUN(
[#include <stdio.h>
int main()
{
  FILE *conftest;
  if ((conftest = fopen("conftest.dat", "w")) == NULL) exit(1);
  if (fclose(conftest)) exit(1);
  if ((conftest = fopen("conftest.dat", "rb+")) == NULL) exit(1);
  if (fputs("testing ANSI for stdio\n", conftest) == EOF) exit(1);
  exit(0);
}],
krb5_cv_has_ansi_stdio=yes, krb5_cv_has_ansi_stdio=no,
krb5_cv_has_ansi_stdio=yes)])dnl assume ANSI in cross environment
AC_MSG_RESULT($krb5_cv_has_ansi_stdio)
if test $krb5_cv_has_ansi_stdio = yes; then
AC_DEFINE(ANSI_STDIO,1,[Define if ANSI stdio is present (in particular "b" option to fopen)])
fi
dnl
dnl then from osconf.h, we have
dnl
AC_HEADER_TIME
AC_CHECK_TYPE(time_t, long)
dnl
dnl Determine where to put the replay cache.
dnl
AC_MSG_CHECKING([for replay cache directory])
AC_CACHE_VAL(krb5_cv_sys_rcdir,
[
for t_dir in /var/tmp /usr/tmp /var/usr/tmp /tmp ; do
	test -d $t_dir || continue
	krb5_cv_sys_rcdir=$t_dir
	break
done])dnl
AC_MSG_RESULT($krb5_cv_sys_rcdir)
KRB5_RCTMPDIR=$krb5_cv_sys_rcdir
AC_SUBST(KRB5_RCTMPDIR)
dnl
dnl
AC_MSG_CHECKING(for socklen_t)
AC_CACHE_VAL(krb5_cv_has_type_socklen_t,
[AC_TRY_COMPILE(
[#include <sys/types.h>
#include <sys/socket.h>
],[sizeof (socklen_t);],
krb5_cv_has_type_socklen_t=yes,krb5_cv_has_type_socklen_t=no)])
AC_MSG_RESULT($krb5_cv_has_type_socklen_t)
if test $krb5_cv_has_type_socklen_t = yes; then
    AC_DEFINE(HAVE_SOCKLEN_T,1,[Define if there is a socklen_t type. If not, probably use size_t])
fi
dnl
AC_MSG_CHECKING(for struct lifconf)
AC_CACHE_VAL(krb5_cv_has_struct_lifconf,
[AC_TRY_COMPILE(
[#include <sys/socket.h>
#include <net/if.h>
],[sizeof (struct lifconf);],
krb5_cv_has_struct_lifconf=yes,krb5_cv_has_struct_lifconf=no)])
AC_MSG_RESULT($krb5_cv_has_struct_lifconf)
if test $krb5_cv_has_struct_lifconf = yes; then
    AC_DEFINE(HAVE_STRUCT_LIFCONF,1,[Define if there is a struct lifconf.])
fi
dnl HP-UX 11 uses stuct if_laddrconf
AC_MSG_CHECKING(for struct if_laddrconf)
AC_CACHE_VAL(krb5_cv_has_struct_if_laddrconf,
[AC_TRY_COMPILE(
[#include <sys/socket.h>
#include <net/if.h>
#include <net/if6.h>
],[sizeof (struct if_laddrconf);],
krb5_cv_has_struct_if_laddrconf=yes,krb5_cv_has_struct_if_laddrconf=no)])
AC_MSG_RESULT($krb5_cv_has_struct_if_laddrconf)
if test $krb5_cv_has_struct_if_laddrconf = yes; then
    AC_DEFINE(HAVE_STRUCT_IF_LADDRCONF,1,[Define if there is a struct if_laddrconf.])
fi
dnl
dnl
AC_MSG_CHECKING([for h_errno in netdb.h])
AC_CACHE_VAL(krb5_cv_header_netdb_h_h_errno,
[AC_TRY_COMPILE(
	[#include <netdb.h>],
	[int x = h_errno;], krb5_cv_header_netdb_h_h_errno=yes,
	krb5_cv_header_netdb_h_h_errno=no)])
AC_MSG_RESULT($krb5_cv_header_netdb_h_h_errno)
if test $krb5_cv_header_netdb_h_h_errno = yes; then
    AC_DEFINE([HAVE_NETDB_H_H_ERRNO], 1,
	[Define if netdb.h declares h_errno])
fi
dnl
dnl
AC_ARG_ENABLE([athena],
[  --enable-athena         build with MIT Project Athena configuration],
AC_DEFINE(KRB5_ATHENA_COMPAT,1,[Define if MIT Project Athena default configuration should be used]),)

if test "$KRB4_LIB" = ''; then
	AC_MSG_NOTICE(No Kerberos 4 compatibility)
	maybe_kerberosIV=
else
	AC_MSG_NOTICE(Kerberos 4 compatibility enabled)
	maybe_kerberosIV=kerberosIV
	AC_DEFINE(KRB5_KRB4_COMPAT,1,[Define if Kerberos V4 backwards compatibility should be supported])
fi
AC_SUBST(maybe_kerberosIV)
dnl
AC_C_INLINE
AH_TOP([
#ifndef KRB5_AUTOCONF_H
#define KRB5_AUTOCONF_H
])
AH_BOTTOM([
#if defined(__GNUC__) && !defined(inline)
/* Silence gcc pedantic warnings about ANSI C.  */
# define inline __inline__
#endif
#endif /* KRB5_AUTOCONF_H */
])
dnl
dnl Not used yet, but let's find out what we've got on the platforms
dnl we're working with....
AC_CHECK_HEADERS(inttypes.h stdint.h)
AC_CHECK_TYPES([uint32_t, int32_t, uint64_t, int64_t, uint_least32_t, uintptr_t, uintmax_t, long long], , , [
#ifdef HAVE_STDINT_H
# include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
# include <inttypes.h>
#endif
])
dnl
dnl Test for POSIX 2001 *printf support (X/Open System Interfaces extension
dnl to ANSI/ISO C 1999 specification).  Specifically, positional
dnl specifications; not checking for other features like %zx at present.
AC_MSG_CHECKING(for POSIX printf positional specification support)
AC_CACHE_VAL(ac_cv_printf_positional,[
AC_TRY_RUN([
#include <stdio.h>
#include <string.h>
const char expected[] = "200 100";
int main () {
    char buf[30];
    sprintf(buf, "%2\$x %1\$d", 100, 512);
    if (strcmp(expected, buf)) {
	fprintf(stderr,"bad result: <%s> wanted: <%s>\n", buf, expected);
	return 1;
    }
    return 0;
}],
  ac_cv_printf_positional=yes,
  ac_cv_printf_positional=no,
  AC_MSG_ERROR([Cannot test for printf positional argument support when cross compiling]))])
dnl Nothing for autoconf.h for now.
AC_MSG_RESULT($ac_cv_printf_positional)
dnl
dnl
dnl Check for thread safety issues.
dnl (Is there a better place for this?)
dnl tsfuncs="getpwnam_r getpwuid_r gethostbyname_r getservbyname_r gmtime_r localtime_r"
dnl Removed getpwnam_r and getpwuid_r because include/configure.in has some
dnl more careful checks, and may decide to pretend that they're not found if
dnl the function signatures can't be figured out.
tsfuncs="gethostbyname_r getservbyname_r gmtime_r localtime_r"
AC_CHECK_FUNCS($tsfuncs)
if test "$enable_thread_support" = yes; then
  tsmissing=""
  for ts in $tsfuncs; do
    if eval "test \"\${ac_cv_func_$ts}\" != yes"; then
      tsmissing="$tsmissing $ts"
    fi
  done
  if test "$ac_cv_func_res_nsearch/$ac_cv_lib_resolv_res_nsearch" = "no/no"; then
    tsmissing="$tsmissing res_nsearch"
  fi
  if test "$tsmissing" != ""; then
    AC_MSG_WARN([Some functions that are needed for library thread])
    AC_MSG_WARN([safety appear to be missing.])
    for ts in $tsmissing; do
      AC_MSG_WARN([  missing thread-safe function: $ts])
    done
    AC_MSG_WARN([Without these functions, the installed libraries])
    AC_MSG_WARN([may not be thread-safe.])
  fi # tsmissing not empty
fi # enable_thread_support
dnl
HOST_TYPE=$krb5_cv_host
AC_SUBST(HOST_TYPE)
dnl
dnl
if test "$COM_ERR_VERSION" = k5 ; then
  AC_CONFIG_SUBDIRS(util/et)
fi
if test "$SS_VERSION" = k5 ; then
  AC_CONFIG_SUBDIRS(util/ss)
fi
AC_CONFIG_SUBDIRS(util/profile lib/crypto lib/krb5 lib/des425 lib/apputils)
if test -n "$KRB4_LIB"; then
  AC_CONFIG_SUBDIRS(lib/krb4)
fi
AC_CONFIG_SUBDIRS(lib/kdb lib/gssapi lib/rpc lib/kadm5)
ldap_plugin_dir=""
ldap_lib=""
if test -n "$OPENLDAP_PLUGIN"; then
  AC_CHECK_HEADERS(ldap.h lber.h)
  AC_CONFIG_SUBDIRS(plugins/kdb/ldap/libkdb_ldap)
  K5_GEN_MAKEFILE(plugins/kdb/ldap)
  K5_GEN_MAKEFILE(plugins/kdb/ldap/ldap_util)
  ldap_plugin_dir=plugins/kdb/ldap
fi
AC_SUBST(ldap_plugin_dir)

AC_CONFIG_SUBDIRS(kadmin clients plugins/kdb/db2 appl tests)
AC_CONFIG_FILES(krb5-config, [chmod +x krb5-config])
V5_AC_OUTPUT_MAKEFILE(. util util/support util/send-pr lib kdc slave krb524 config-files gen-manpages include include/kerberosIV)
